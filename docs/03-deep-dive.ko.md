# ROD, TFD, DGTF: Deep Dive

## 목차
1. [서론](#서론)
2. [인간 사고의 두 시스템](#인간-사고의-두-시스템)
3. [ROD: 심층 분석](#rod-심층-분석)
4. [TFD: 심층 분석](#tfd-심층-분석)
5. [DGTF: 심층 분석](#dgtf-심층-분석)
6. [세 방법론의 통합](#세-방법론의-통합)
7. [실전 적용의 심리학](#실전-적용의-심리학)

---

## 서론

이 문서는 ROD, TFD, DGTF의 **철학적 배경**과 **심리학적 근거**를 깊이 있게 다룹니다.

### 이 문서가 다루는 것:
- **왜** 이 방법론들이 필요한가?
- **왜** 이런 방식으로 작동하는가?
- 인간 심리학과 어떻게 연결되는가?
- "나쁜 긴급 결정"이란 무엇인가?

### 이 문서를 읽어야 하는 사람:
- 방법론의 근본 원리를 이해하고 싶은 개발자
- 팀에 이 방법론을 도입하려는 리더
- 소프트웨어 개발 방법론을 연구하는 사람
- 더 나은 개발자가 되고 싶은 모든 사람

**참고**: 빠른 적용을 원하신다면 [실전 가이드](02-practical-guide.ko.md)를 먼저 보세요.

---

## 인간 사고의 두 시스템

### Daniel Kahneman의 Dual Process Theory

Nobel 경제학상 수상자 Daniel Kahneman의 연구는 인간의 사고 과정을 두 가지 시스템으로 설명합니다.

#### System 1 (빠른 사고)
```
특징:
- 자동적, 직관적, 즉각적
- 노력이 거의 필요 없음
- 빠른 판단과 반응
- 감정적, 연상적

장점:
- 빠른 결정
- 생존에 유리
- 에너지 절약

단점:
- 편향에 취약
- 복잡한 문제에 부적합
- 실수하기 쉬움
- 압박 상황에서 지배적
```

#### System 2 (느린 사고)
```
특징:
- 의도적, 분석적, 신중함
- 집중력과 노력 필요
- 논리적 추론
- 체계적 분석

장점:
- 정확한 판단
- 복잡한 문제 해결
- 장기적 사고

단점:
- 느림
- 에너지 소모
- 지치면 작동 안 함
- 압박에서 회피됨
```

---

### 개발 단계별 사고 시스템

소프트웨어 개발의 각 단계는 **서로 다른 사고 시스템**을 자연스럽게 유도합니다.

#### 설계 단계의 심리 상태
```
환경:
✓ 시간 여유
✓ 낮은 압박
✓ 탐색적 사고 가능
✓ 실수의 비용 낮음

자연스러운 시스템:
→ System 2 활성화 용이
→ 깊은 사고 가능
→ 완전한 분석 가능
```

#### 구현 단계의 심리 상태
```
환경:
✗ 시간 부족
✗ 마감일 압박
✗ 요구사항 변경
✗ 실수의 비용 높음

자연스러운 시스템:
→ System 1이 우세
→ 빠른 결정 추구
→ "일단 되게" 심리
→ 나쁜 긴급 결정 위험
```

---

### 핵심 통찰

> **잘못된 시점에 잘못된 시스템을 사용하면 문제가 발생한다.**

```
문제의 패턴:

설계 단계에서 System 1 사용:
"대충 이럴 거야" → 불완전한 설계 → Missing 발생

구현 단계에서 System 1 지배:
"빨리 해야 해" → 나쁜 긴급 결정 → 기술 부채
```

**ROD, TFD, DGTF는 이 문제를 해결합니다.**

---

## ROD: 심층 분석

### 핵심 개념

**정의:**
> 설계 단계에서 System 2를 활용하여 완전한 서비스 체인을 구축함으로써,
> 구현 단계의 혼란과 System 1의 나쁜 긴급 결정을 방지한다.

**핵심 원칙:**
> **"More is better than missing"**
> 
> 빠진 것보다는 더 많은 게 낫다

---

### ROD가 해결하는 근본 문제

#### 문제: "나쁜 긴급 결정 (Bad Emergency Decisions)"

**시나리오:**
```
구현 중 발견:
"어? 사용자 객체를 어떻게 만들지?"
"설계에 없네?"

개발자의 심리 상태:
- 압박 받음 (마감일 다가옴)
- 혼란스러움 (설계에 없음)
- 스트레스 (시간 부족)
- System 1 활성화

System 1의 "해결책":
→ "전역 변수로 하자!"
→ "싱글톤 쓰면 되지!"
→ "static 필드로!"
→ "일단 하드코딩하고 나중에 고치자!"

결과:
→ 나쁜 아키텍처
→ 기술 부채
→ 결합도 증가
→ 나중에 고치기 어려움
→ 더 많은 시간 소요
```

---

### "Missing"의 심리학

#### 왜 Missing이 위험한가?

**제거 vs 추가의 비대칭성:**

```
불필요한 것 제거 (쉬움):
상황:
- 코드가 이미 존재
- "안 쓰이네" (명확한 증거)
- 시간 여유 (당장 급하지 않음)

심리:
- System 2 작동 가능
- 분석적 판단
- 안전한 결정

불필요한 것 추가 (어려움):
상황:
- 빈 공간 (막막함)
- "필요한데 없네" (혼란)
- 시간 압박 (구현 중)

심리:
- System 1 지배
- 긴급 결정
- 위험한 선택
```

---

### ROD의 해결책: 완전한 서비스 체인

#### 서비스 체인의 정의

**서비스 체인이란:**
> 모든 요구사항을 달성하기 위해 필요한
> 완전한 책임들의 연결

**완전함의 기준:**
```
질문: "이 서비스 체인만으로 요구사항을 달성할 수 있는가?"

YES → 완전함 (Missing 없음)
NO → Missing 존재 → 서비스 추가 필요
```

---

### ROD의 엄격한 규칙

ROD는 다음을 **금지**합니다:

#### 1. Constructor 금지

**왜?**
```
Constructor 사용 시:
func NewUser(name string) User {
    return User{name: name}
}

→ 객체 생성 방법이 코드에 하드코딩됨
→ 생성 로직 변경 불가능
→ 테스트에서 Mock 어려움

ROD 방식:
type UserFactory interface {
    CreateUser(name string) (User, error)
}

→ 생성 방법을 서비스로 제공
→ 언제든 교체 가능
→ 테스트 쉬움
```

#### 2. Static Field 금지

**왜?**
```
Static field 사용 시:
var GlobalDB *sql.DB

→ 전역 상태
→ 의존성 숨김
→ 테스트 불가능
→ 병렬 테스트 불가능

ROD 방식:
type DatabaseProvider interface {
    GetDatabase() (*sql.DB, error)
}

→ 의존성 명시
→ 교체 가능
→ 테스트 가능
```

#### 3. 가정 금지

**왜?**
```
가정 사용 시:
"Database는 항상 연결되어 있을 거야"
"Config는 어딘가에 있겠지"

→ Missing 발생
→ 구현 단계에서 발견
→ 나쁜 긴급 결정

ROD 방식:
"Database는 누가 제공하는가?" → DatabaseProvider
"Config는 누가 관리하는가?" → ConfigManager

→ 모든 책임 명시
→ Missing 없음
```

---

### "More is better than missing"의 깊은 의미

#### 전략적 선택

```
설계 단계 (시간 여유):
불확실성: "이게 필요할까?"
선택: 일단 포함 (More)
이유: 나중에 제거 쉬움

구현 단계 (시간 압박):
발견: "이게 필요한데 없네?"
상황: 발생하지 않음 (ROD가 방지)
결과: 나쁜 긴급 결정 없음
```

#### 심리학적 보험

```
ROD는 "심리학적 보험"입니다:

보험료: 설계 시 약간의 추가 노력
보장: 구현 시 나쁜 긴급 결정 방지
가치: 기술 부채 예방, 품질 유지
```

---

### SOLID와의 연결

#### 왜 ROD가 SOLID를 강제하는가?

**이유:**
```
구현 단계의 현실:
- 요구사항이 자주 변경됨
- "이 방법 말고 저 방법으로"
- 시간 압박 속 변경

SOLID 없이:
→ 변경 = 코드 전체 수정
→ 위험, 버그
→ 더 많은 시간

SOLID 있으면:
→ 변경 = 서비스 교체
→ 안전, 격리
→ 빠른 대응
```

**예시:**
```go
// SOLID 적용 (인터페이스)
type PaymentProcessor interface {
    Process(amount float64) error
}

// 구현 1: 신용카드
type CreditCardProcessor struct{}

// 구현 2: PayPal (요구사항 변경)
type PayPalProcessor struct{}

// 변경 시:
// processor 교체만 하면 됨
// 다른 코드 영향 없음
```

---

### ROD의 가치

```
1. 구현 단계의 혼란 제거
   완전한 서비스 체인 = 명확한 가이드
   Missing 없음 = "어떻게 하지?" 없음

2. System 1의 나쁜 긴급 결정 방지
   압박 속에서도 설계 따르기만 하면 됨
   "전역 변수!", "싱글톤!" 불필요

3. 요구사항 변경에 안전하게 대응
   SOLID: 서비스 교체 가능
   다른 부분 영향 없음

4. 기술 부채 최소화
   깨끗한 아키텍처 유지
   유지보수 가능한 구조

5. 예측 가능한 개발
   서비스 체인 = 작업 목록
   진행 상황 측정 가능
```

---

## TFD: 심층 분석

### 핵심 개념

**정의:**
> 설계와 함께 (또는 그 전에) 테스트를 설계하여,
> 요구사항을 명확히 하고 품질을 보증한다.

**핵심 원칙:**
> **"요구사항 = 테스트"**
> 
> 테스트는 사후 작업이 아니라 명세서다

---

### TFD가 해결하는 문제

#### 전통적 접근의 함정

```
전통적 흐름:
설계 → 구현 → "아, 테스트해야지" → 테스트 작성

문제점:
1. 테스트가 구현에 맞춰짐
   - 요구사항이 아닌 "구현된 것" 테스트
   - 버그도 함께 통과시킴

2. 엣지 케이스 누락
   - "이미 작동하는데 뭐하러"
   - System 1: "되네? 끝!"

3. 테스트하기 어려운 구조
   - 이미 구현됨
   - 리팩토링 어려움
   - "그냥 이대로..."

4. 불완전한 커버리지
   - "중요한 것만"
   - 무엇이 중요한지 모름
```

---

### TFD의 해결책

#### 테스트 우선 설계

**흐름:**
```
1. 설계 (ROD)
   서비스 체인 정의

2. 테스트 설계 (TFD)
   각 서비스마다:
   - 정상 케이스 테스트
   - 에러 케이스 테스트
   - 엣지 케이스 테스트
   - 성능 테스트

3. 구현
   테스트를 통과하도록 구현

4. 검증
   모든 테스트 통과 = 완료
```

---

### "요구사항 = 테스트"의 의미

#### 테스트는 명세서다

```
잘못된 관점:
"테스트 = 버그를 찾는 도구"

올바른 관점:
"테스트 = 요구사항의 명세서"

예시:
요구사항: "사용자 로그인 시 세션 생성"

테스트 (명세서):
- 올바른 자격증명 → 세션 생성됨
- 잘못된 비밀번호 → 에러 반환
- 빈 입력 → 에러 반환
- 이미 로그인됨 → 기존 세션 반환

→ 이제 요구사항이 명확함!
```

---

### TFD와 V-Model의 연결

```
V-Model의 지혜:

요구사항 정의 ←→ 인수 테스트
    ↓                ↑
시스템 설계   ←→ 시스템 테스트
    ↓                ↑
상세 설계     ←→ 통합 테스트
    ↓                ↑
구현         ←→ 단위 테스트

TFD의 적용:
각 단계에서 "어떻게 검증할까"를
"무엇을 만들까"와 동시에 결정
```

---

### TFD와 ROD의 시너지

```
ROD: "무엇을 만들 것인가"
서비스 A, B, C가 필요함

TFD: "올바르게 작동하는가"
서비스 A:
  - 테스트 1, 2, 3
서비스 B:
  - 테스트 4, 5, 6
서비스 C:
  - 테스트 7, 8, 9

함께:
완전한 명세서 = ROD + TFD
```

---

### TFD의 가치

```
1. 명확한 요구사항
   테스트 = 명세서
   무엇을 구현해야 하는지 명확

2. 완전한 테스트 커버리지
   엣지 케이스 누락 없음
   모든 시나리오 커버

3. 테스트 가능한 설계 강제
   의존성 주입
   인터페이스 사용
   Mock 가능한 구조

4. 자신감과 안정성
   모든 테스트 통과 = 올바르게 작동
   리팩토링 안전
   회귀 버그 방지

5. 살아있는 문서
   테스트가 사용 방법을 보여줌
   항상 최신 상태 유지

6. 진행 상황 측정 가능
   X개 테스트 중 Y개 통과
   얼마나 남았는지 명확
```

---

## DGTF: 심층 분석

### 핵심 개념

**정의:**
> 압박 상황에서도 System 2를 활성화하여,
> System 1의 나쁜 긴급 결정을 방지하고 품질을 유지한다.

**핵심 원칙:**
> **"Slow is smooth, smooth is fast"**
> 
> 느리게 하면 부드럽고, 부드러우면 빠르다

---

### DGTF가 해결하는 문제

#### 압박 상황의 심리학

```
트리거:
- 마감일 압박
- 요구사항 변경
- 버그 발견
- 팀 압박

심리적 반응:
- 스트레스 증가
- System 1 활성화
- "빨리 해결해야 해!"
- 첫 번째 떠오른 해결책에 집착

System 1의 결정:
- 부작용 고려 안 함
- "일단 되게 하고 나중에 고치자"
- 빠른 해킹
- 지름길 선택

결과:
- 기술 부채
- 새로운 버그
- 더 복잡해짐
- 결국 더 많은 시간 소요
```

---

### DGTF의 해결책

#### 의식적 통제

```
1. 멈추기 (Pause)
   트리거 인식:
   - "빨리" 충동 느낌
   - 스트레스 자각
   - System 1 활성화 인지
   
   행동:
   - "잠깐, 생각하자"
   - 키보드에서 손 떼기
   - 심호흡

2. 생각하기 (Think)
   System 2 활성화:
   - 설계 확인 (ROD)
   - 테스트 확인 (TFD)
   - 영향 범위 분석
   - 대안 검토
   
   질문:
   - "이게 정말 올바른 방법인가?"
   - "부작용은 없나?"
   - "다른 방법은?"

3. 진행하기 (Proceed)
   신중한 구현:
   - 하나씩 완성
   - 지속적 검증
   - 테스트 확인
```

---

### 운전 비유

#### 운전면허증 ≠ 좋은 운전자

```
나쁜 운전자 (System 1 지배):
- 빠르게 차선 변경
- 확인 안 함
- 공격적 운전
- 급가속, 급제동

결과:
- 사고 위험 높음
- 스트레스
- 연료 낭비
- 전체적으로 느림 (사고, 벌금)

좋은 운전자 (System 2 활용):
- 일관된 속도
- 안전거리 유지
- 예측하고 대응
- 부드러운 조작

결과:
- 사고 없음
- 편안함
- 연료 효율
- 전체적으로 빠름
```

**프로그래밍도 동일:**
```
코딩 능력 ≠ 좋은 프로그래머
좋은 프로그래머 = 기술 + 습관 + 태도
```

---

### DGTF ≠ 느림

#### 흔한 오해

```
❌ "DGTF = 천천히 일하기"
❌ "DGTF = 생산성 낮음"
❌ "DGTF = 마감 못 지킴"
```

#### 진실

```
✅ DGTF = 신중하게 일하기
✅ DGTF = 품질 우선
✅ DGTF = 지속 가능한 속도

역설:
┌─────────────────────────┐
│ 성급한 개발:            │
│ 빠름 → 버그 → 수정 →   │
│ 더 많은 버그 → 리팩토링 │
│ → 전체적으로 느림       │
└─────────────────────────┘

┌─────────────────────────┐
│ DGTF 개발:              │
│ 신중 → 적은 버그 →      │
│ 적은 수정 → 안정적 →    │
│ 전체적으로 빠름         │
└─────────────────────────┘
```

---

### DGTF의 실천

#### Weinberg의 "Egoless Programming"

```
집착하지 않는 프로그래밍:

문제:
"내 코드" = "나"
비판 = 개인 공격
방어적 태도

DGTF:
"내 코드" ≠ "나"
비판 = 개선 기회
열린 태도

효과:
- 더 나은 코드 리뷰
- 팀 협업 향상
- 지속적 개선
```

#### 명시적 합의

```
나쁜 패턴:
개발자: "이렇게 하면 되겠네"
→ 혼자 결정
→ 구현
→ 나중에 문제

DGTF 패턴:
개발자: "이렇게 하려는데 어떤가요?"
팀: "이 부분은 어떻게?"
개발자: "아, 그럼 이렇게"
팀: "좋습니다"
→ 구현
→ 문제 없음
```

---

### DGTF의 가치

```
1. 적은 버그
   신중한 구현
   철저한 검증
   조기 발견

2. 적은 재작업
   처음부터 올바르게
   기술 부채 최소화

3. 높은 코드 품질
   깨끗한 구조
   유지보수 쉬움

4. 지속 가능한 속도
   번아웃 없음
   일정한 생산성
   장기적으로 빠름

5. 팀 신뢰 구축
   안정적인 배포
   예측 가능한 일정
   품질 보장

6. 개인 성장
   System 2 훈련
   전문성 향상
   경력 발전
```

---

## 세 방법론의 통합

### 개발 프로세스의 완전한 구조

```
┌──────────────────────────────────────┐
│ 설계 단계: ROD                       │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━       │
│                                      │
│ 상황: 시간 여유, 낮은 압박           │
│ 시스템: System 2 활성                │
│                                      │
│ 작업:                                │
│ • 완전한 서비스 체인 구축            │
│ • Missing 제거                       │
│ • SOLID 적용                         │
│                                      │
│ 효과: "무엇을 만들 것인가" 명확      │
└──────────────────────────────────────┘
            ↓
┌──────────────────────────────────────┐
│ 검증 설계 단계: TFD                  │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━       │
│                                      │
│ 시스템: System 2 활성                │
│                                      │
│ 작업:                                │
│ • 각 서비스마다 테스트 케이스        │
│ • 완료 기준 정의                     │
│                                      │
│ 효과: "올바르게 작동하는가" 검증     │
└──────────────────────────────────────┘
            ↓
┌──────────────────────────────────────┐
│ 구현 단계: DGTF                      │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━       │
│                                      │
│ 상황: 시간 부족, 높은 압박           │
│ 위험: System 1 우세                  │
│ 대응: DGTF로 System 2 활성화         │
│                                      │
│ 보호 장치:                           │
│ • ROD: 서비스 체인 가이드            │
│ • TFD: 테스트 기준                   │
│ • DGTF: 신중한 진행                  │
│                                      │
│ 효과: "어떻게 만들 것인가" 안전      │
└──────────────────────────────────────┘
```

---

### 시너지 효과

#### 단독 vs 통합

```
ROD 단독:
✓ 완전한 설계
✗ 품질 보증 부족

TFD 단독:
✓ 품질 보증
✗ 설계 불완전 가능

DGTF 단독:
✓ 신중한 진행
✗ 방향성 부족

ROD + TFD + DGTF:
✓ 완전한 설계 (ROD)
✓ 품질 보증 (TFD)
✓ 신중한 진행 (DGTF)
✓ System 1 통제
✓ 지속 가능
```

---

### 실전 통합 예시

```
프로젝트: 결제 시스템

1. ROD (설계):
   서비스 체인:
   - PaymentValidator
   - PaymentProcessor
   - TransactionLogger
   - NotificationSender
   - ErrorHandler
   
   → Missing 없음
   → 구현 시 혼란 없음

2. TFD (검증):
   PaymentProcessor 테스트:
   - 정상 결제 → 성공
   - 잔액 부족 → 에러
   - 네트워크 오류 → 재시도
   - 타임아웃 → 롤백
   
   → 요구사항 명확
   → 완료 기준 명확

3. DGTF (구현):
   상황: 마감 3일 전, 압박
   
   유혹: "일단 하드코딩하고..."
   DGTF: "잠깐, 설계 확인"
   
   행동:
   - ROD 설계 따름
   - TFD 테스트 통과
   - 하나씩 신중히
   
   결과:
   - 깨끗한 코드
   - 모든 테스트 통과
   - 기술 부채 없음
```

---

## 실전 적용의 심리학

### 저항의 이유

#### "시간이 없어요"

```
표면적 이유:
"ROD/TFD/DGTF 하려면 시간이 더 걸려요"

진짜 이유:
System 1: "빨리빨리!"
압박: "당장 결과 보여줘야 해"
두려움: "새로운 방법 = 위험"

현실:
처음: 약간 느린 것처럼 보임
나중: 훨씬 빠름 (재작업 없음)
```

#### 극복 방법

```
작게 시작:
- 작은 기능 하나에만 적용
- 결과 측정
- Before/After 비교
- 팀과 공유

증거 수집:
- 버그 수 감소
- 리팩토링 시간 감소
- 코드 리뷰 시간 단축
- 팀 만족도 증가
```

---

### 습관 형성

#### 21일 법칙

```
Week 1: 의식적 노력
- ROD 체크리스트 보며 설계
- TFD 테스트 먼저 작성
- DGTF 트리거 의식적 인식

Week 2: 익숙해짐
- 체크리스트 덜 봄
- 테스트 우선이 자연스러움
- 멈추기가 습관화

Week 3: 자동화
- 체크리스트 없이도 됨
- 테스트 먼저가 기본
- System 2가 기본값
```

---

### 팀 문화

#### 심리적 안전

```
필요한 것:
- 실수해도 괜찮은 환경
- "DGTF" 외칠 수 있는 용기
- "잠깐, 생각해보자" 가능한 분위기
- 속도보다 품질 우선

만드는 방법:
- 리더가 먼저 실천
- 실수 공유 문화
- 학습 기회로 전환
- 품질 보상 시스템
```

---

## 결론

### 핵심 메시지

```
ROD:
"구현 전에 완전한 설계"
→ Missing 없음
→ 나쁜 긴급 결정 없음

TFD:
"구현 전에 테스트 설계"
→ 명확한 요구사항
→ 품질 보증

DGTF:
"압박 속에서도 신중하게"
→ System 2 활성화
→ 지속 가능한 품질
```

### 궁극적 목표

> **지속 가능한 고품질 소프트웨어 개발**

```
단기:
✓ 깨끗한 코드
✓ 적은 버그
✓ 빠른 배포

장기:
✓ 낮은 기술 부채
✓ 유지보수 용이
✓ 팀 행복
✓ 경력 성장
```

---

### 시작하기

```
1주차: 학습
- 이 문서 읽기
- 개념 이해
- 팀과 논의

2주차: 실험
- 작은 기능에 적용
- ROD로 설계
- TFD로 테스트
- DGTF로 구현

3주차: 측정
- 결과 분석
- Before/After
- 팀 피드백

4주차: 확장
- 더 큰 기능에 적용
- 팀 전체 도입
- 지속적 개선
```

---

### 마지막 조언

> "완벽하게 하려고 하지 마세요"
> 
> ROD, TFD, DGTF도 "DONT GO TOO FAST"로 도입하세요
> 
> 천천히, 하나씩, 확실하게

---

**Remember: DONT GO TOO FAST** ⏱️

**다음 단계:**
- [실전 가이드](02-practical-guide.ko.md)에서 구체적인 적용 방법 학습
- [개념과 가치](01-concepts-and-values.ko.md)에서 요약 복습
