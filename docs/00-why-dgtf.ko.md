# 왜 ROD, TFD, DGTF가 필요한가?

## 목차
1. [서론](#서론)
2. [Good Software란 무엇인가?](#good-software란-무엇인가)
3. [운전 비유](#운전-비유)
4. [현실의 문제](#현실의-문제)
5. [해결책](#해결책)
6. [다음 단계](#다음-단계)

---

## 서론

이 문서는 ROD, TFD, DGTF 방법론이 **왜 필요한지**, 그리고 **어떤 문제를 해결하는지**를 설명합니다.

### 이 문서를 읽어야 하는 이유:
- ROD, TFD, DGTF를 팀에 도입하려는 리더
- "왜 이런 방법론이 필요한가?" 궁금한 개발자
- 좋은 소프트웨어가 무엇인지 이해하고 싶은 사람
- 현재 개발 방식의 문제점을 인식하고 있는 사람

---

## Good Software란 무엇인가?

### 흔한 오해

```
"좋은 소프트웨어 = 기능이 많은 소프트웨어?"
"좋은 소프트웨어 = 빠른 소프트웨어?"
"좋은 소프트웨어 = 최신 기술을 쓴 소프트웨어?"
```

---

### ISO/IEC 25010 품질 모델

국제 표준 ISO/IEC 25010은 소프트웨어 품질을 **9가지 특성**으로 정의합니다:

```
1. Functionality (기능성)
   - 소프트웨어가 요구된 기능을 제공하는가?

2. Reliability (신뢰성)
   - 소프트웨어가 안정적으로 작동하는가?
   - 다운되지 않는가?

3. Performance Efficiency (성능 효율성)
   - 실행 시간이 적절한가?
   - 메모리 사용량이 적절한가?

4. Usability (사용성)
   - 사용자가 쉽게 사용할 수 있는가?

5. Security (보안성)
   - 외부 공격으로부터 안전한가?

6. Compatibility (호환성)
   - 다른 소프트웨어/시스템과 잘 작동하는가?

7. Maintainability (유지보수성)
   - 수정하기 쉬운가?
   - 버그를 찾기 쉬운가?

8. Portability (이식성)
   - 다른 환경에서도 작동하는가?

9. Functional Suitability (기능 적합성)
   - 필요한 기능이 적절히 제공되는가?
```

---

### 기능성 vs 비기능적 요소

**기능성 (Functional)**:
```
사용자가 명시적으로 요구하는 것
- "사용자 로그인 기능"
- "결제 처리 기능"
- "데이터 조회 기능"
```

**비기능적 요소 (Non-Functional)**:
```
사용자가 "당연히"라고 생각하는 것
- "당연히 다운되면 안 되지"
- "당연히 빨라야지"
- "당연히 안전해야지"
- "당연히 버그가 없어야지"
```

---

### 나쁜 소프트웨어 경험

우리 모두 경험해봤을 것들:

```
✗ 소프트웨어가 약속한 대로 동작하지 않아
✗ 특정 기능만 수행하면 죽어
✗ 메모리 사용량이 너무 많아
✗ 사용자가 예상치 못한 방법으로 사용하면 다운
✗ 오류 발생 시 원인을 도대체 알 수가 없어
✗ 실행 시간이 너무 오래 걸려
✗ 새로운 OS에서 설치 실패
✗ 다른 소프트웨어와 충돌 발생
✗ 좀 오래 사용하면 다운
```

**질문**: 이런 문제들은 왜 발생할까요?

---

## 운전 비유

### 시나리오: 목적지에 도착했습니다!

```
결과:
✓ 목적지에 늦지 않게 도착했다!!!

하지만:
✗ 나 때문에 2건의 교통사고 발생!!!
✗ 동승자는 멀미/메스꺼움으로 구토 시작!!!
✗ 차는 앞 범퍼가 박살 남!!!
✗ 과속 카메라 3회 촬영!!
```

**질문**: 이 사람은 좋은 운전자인가?

---

### Good Software == Good Driving?

| 운전 | 소프트웨어 |
|------|-----------|
| 목적지 도착 | 기능 구현 |
| 사고 없음 | 버그 없음 |
| 승객 편안함 | 사용자 경험 |
| 차량 손상 없음 | 시스템 안정성 |
| 교통법규 준수 | 표준/규약 준수 |

**핵심 통찰**:
> 목적지에 도착 ≠ 좋은 운전
> 
> 기능 구현 ≠ 좋은 소프트웨어

---

### 운전의 원칙들

```
PRINCIPLE OF DRIVING:

✓ 오른쪽으로 가려면 오른쪽 방향 지시등을 켜고 핸들을 오른쪽으로 돌린다
✓ 뒤쪽에서 다가오는 차는 사이드미러와 룸미러로 주시한다
✓ 어두워지면 라이트를 켠다
✓ 왼쪽으로 가려면 왼쪽 방향 지시등을 켜고 핸들을 왼쪽으로 돌린다
✓ 앞으로 가려면 엑셀레이터를 밟는다
✓ 멈추려면 브레이크를 밟는다
✓ 비가 오면 와이퍼를 켠다
✓ 빨간불이면 가면 안 된다
✓ 파란불이면 가도 된다
```

**질문**: 이렇게만 하면 좋은 운전자가 될 수 있나?

**답**: 아니오!

---

### 좋은 운전자가 되려면?

```
원칙 (Principles):
- 기본적인 조작 방법
- 교통 법규
- 차량 구조 이해

+

태도 (Attitude):
- 안전 의식
- 타인 배려
- 방어 운전

+

습관 (Habits):
- 안전거리 유지
- 규칙적인 확인
- 예측 운전

+

경험 (Experience):
- 다양한 상황 대응
- 위험 인지
- 판단력
```

**핵심**:
> 좋은 운전자 = 운전 면허 + 태도 + 습관 + 경험

---

## 현실의 문제

### 소프트웨어 개발 교육의 현실

John Ousterhout (Stanford 교수, "A Philosophy of Software Design" 저자):

> **"사람들은 80년 넘게 전자 컴퓨터용 프로그램을 작성해 왔지만,**
> **이러한 프로그램을 설계하는 방법이나**
> **좋은 프로그램이 어떤 모습이어야 하는지에 대한**
> **대화는 놀랍게도 거의 없었습니다."**

> **"소프트웨어 설계의 최신 기술은**
> **이후 45년 동안 크게 발전하지 못했습니다."**

> **"우리는 for 루프와 객체 지향 프로그래밍을 가르치지만**
> **소프트웨어 설계는 가르치지 않습니다."**

---

### 우리가 배우는 것

```
대학/교육기관:
✓ 프로그래밍 언어 (Java, Python, C++)
✓ 자료구조 (Array, List, Tree, Graph)
✓ 알고리즘 (정렬, 탐색, 최적화)
✓ 디자인 패턴 (Singleton, Factory, Observer)
✓ 개발 방법론 (Agile, Scrum, Waterfall)

하지만:
✗ 좋은 소프트웨어를 설계하는 방법
✗ 비기능적 요소를 달성하는 방법
✗ 기술 부채를 피하는 방법
✗ 유지보수 가능한 코드를 작성하는 방법
```

---

### 원칙만으로 충분한가?

**SOLID 원칙**:
```
S - Single Responsibility Principle
O - Open/Closed Principle
L - Liskov Substitution Principle
I - Interface Segregation Principle
D - Dependency Inversion Principle
```

**DRY 원칙**:
```
Don't Repeat Yourself
```

**KISS 원칙**:
```
Keep It Simple, Stupid
```

**질문**: 이 원칙들만 알면 좋은 소프트웨어를 만들 수 있나?

**답**: 아니오!

---

### 왜 원칙만으로 부족한가?

```
문제 1: 추상적임
"Single Responsibility"
→ 어디까지가 하나의 책임?
→ 언제 나눠야 하나?
→ 구체적인 방법은?

문제 2: 상황에 따라 다름
"Open/Closed Principle"
→ 언제 열어야 하나?
→ 언제 닫아야 하나?
→ 어떻게 균형을 맞추나?

문제 3: 실천이 어려움
원칙은 알지만:
→ 마감일 압박
→ 요구사항 변경
→ 시간 부족
→ 결국 "일단 되게"
```

---

### 실제 개발 현장의 문제

```
시나리오 1: 마감일 압박
개발자: "SOLID 원칙을 지켜야 하는데..."
관리자: "내일까지 끝내야 해요"
개발자: "일단 하드코딩하고 나중에 고치자"
→ 기술 부채 발생

시나리오 2: 요구사항 변경
개발자: "설계를 다시 해야 하는데..."
관리자: "시간이 없어요, 기존 코드에 추가하세요"
개발자: "전역 변수 하나 추가하면 되긴 하는데..."
→ 아키텍처 붕괴

시나리오 3: 테스트
개발자: "테스트 코드를 작성해야 하는데..."
관리자: "지금은 기능 개발이 급해요"
개발자: "나중에 쓰지 뭐..."
→ 버그 증가
```

---

### 근본 원인

```
원칙 (Principles):
✓ 무엇을 해야 하는지 알려줌
✗ 어떻게 해야 하는지는 모호함
✗ 압박 상황에서 지키기 어려움

필요한 것:
✓ 구체적인 방법론
✓ 실천 가능한 프로세스
✓ 압박 속에서도 지킬 수 있는 습관
✓ 팀 전체의 문화
```

---

## 해결책

### Good Software == Good Driving!

운전자가 되려면:

```
1. 원칙 학습
   - 교통 법규
   - 차량 조작법

2. 태도 함양
   - 안전 의식
   - 타인 배려

3. 습관 형성
   - 안전거리
   - 규칙적 확인

4. 경험 축적
   - 다양한 상황
   - 위험 대응
```

개발자가 되려면:

```
1. 원칙 학습
   - SOLID, DRY, KISS
   - 디자인 패턴

2. 관점 변경 ← ROD, TFD, DGTF
   - 완전한 설계
   - 테스트 우선
   - 신중한 진행

3. 습관 형성 ← ROD, TFD, DGTF
   - 체계적 설계
   - 검증 우선
   - System 2 활성화

4. 문화 구축 ← ROD, TFD, DGTF
   - 품질 우선
   - 팀 협업
   - 지속 가능성
```

---

### ROD, TFD, DGTF가 제공하는 것

#### 1. 구체적인 방법론

```
원칙: "Single Responsibility를 지켜라"
→ 추상적, 모호함

ROD: "완전한 서비스 체인을 먼저 설계하라"
→ 구체적, 실천 가능
→ Constructor 금지, Static field 금지
→ "More is better than missing"
```

#### 2. 실천 가능한 프로세스

```
원칙: "테스트를 작성하라"
→ 언제? 어떻게?

TFD: "설계와 함께 테스트를 설계하라"
→ 설계 단계에서
→ 각 서비스마다
→ 요구사항 = 테스트
```

#### 3. 압박 속 보호 장치

```
현실: "마감일 압박 → 성급한 결정 → 기술 부채"

DGTF: "멈춤 → 생각 → 합의 → 진행"
→ System 1 통제
→ System 2 활성화
→ "Slow is smooth, smooth is fast"
```

---

### 통합 효과

```
ROD (설계):
"무엇을 만들 것인가" 명확
→ 완전한 서비스 체인
→ Missing 없음
→ 구현 단계 혼란 없음

TFD (검증):
"올바르게 작동하는가" 검증
→ 요구사항 = 테스트
→ 완료 기준 명확
→ 품질 보증

DGTF (구현):
"어떻게 만들 것인가" 안전
→ 신중한 진행
→ 나쁜 긴급 결정 방지
→ 지속 가능한 품질

함께:
완전한 개발 프로세스
```

---

### 실제 효과

```
Before (원칙만):
✗ 불완전한 설계 → Missing 발견
✗ 압박 → 성급한 결정
✗ 기술 부채 → 유지보수 어려움
✗ 버그 증가 → 신뢰도 하락

After (ROD + TFD + DGTF):
✓ 완전한 설계 → Missing 없음
✓ 압박 속에도 신중함 유지
✓ 깨끗한 코드 → 유지보수 쉬움
✓ 적은 버그 → 높은 신뢰도
```

---

## 다음 단계

### 학습 경로

```
1. 배경 이해 (현재 문서)
   ✓ 왜 필요한가?
   ✓ 어떤 문제를 해결하나?

2. 개념 학습
   → docs/01-concepts-and-values.ko.md
   - ROD, TFD, DGTF의 핵심 개념
   - 각 방법론의 원칙

3. 실전 적용
   → docs/02-practical-guide.ko.md
   - 단계별 적용 방법
   - 실제 예시
   - 체크리스트

4. 깊이 이해
   → docs/03-deep-dive.ko.md
   - 심리학적 배경
   - 철학적 근거
   - 고급 주제
```

---

### 시작하기

```
팀 리더:
1. 팀과 이 문서 공유
2. "왜 필요한가" 논의
3. 작은 프로젝트에 시범 적용
4. 효과 측정 및 피드백

개인 개발자:
1. 개념 학습
2. 개인 프로젝트에 적용
3. 경험 공유
4. 팀 도입 제안
```

---

## 결론

### 핵심 메시지

```
좋은 소프트웨어 = 좋은 운전

원칙만으로는 부족
→ 구체적인 방법론
→ 실천 가능한 프로세스
→ 압박 속 보호 장치

ROD + TFD + DGTF:
→ 관점 변경
→ 습관 형성
→ 문화 구축
→ 지속 가능한 품질
```

### 시작하세요

> "좋은 운전자가 되는 것처럼,
> 
> 좋은 개발자가 되는 것도
> 
> 학습하고, 연습하고, 습관화하는 것입니다."

---

**다음**: [개념과 가치](01-concepts-and-values.ko.md)에서 ROD, TFD, DGTF의 핵심 개념을 배워보세요.

**Remember: DONT GO TOO FAST** ⏱️
